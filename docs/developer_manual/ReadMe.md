# Руководство начинающего разработчика для EasyEPlanner #

Данное руководство служит новичкам для ознакомления с решением и углубления знаний в проекте без непосредственного исследования кода. Помимо этого руководства, желательно ещё изучить руководство пользователя т.к позволяет изучить варианты использования системы пользователями, а также пользовательский функционал.

**Примечание**: надстройка работает только с одним открытым проектом в EPLAN.

Дополнение подключается к версии **EPLAN 2.8** (*сейчас 2.9*) и новее. Пользовательская документация - [тык](https://github.com/savushkin-r-d/EasyEPLANner/tree/master/docs/user_manual). Документация по API - [тык](https://www.eplan.help/en-US/infoportal/content/api/2.9/index.html).
## Содержание ##
1-Технологический-стек-и-проекты

## 1. Технологический стек и проекты ##

Решение **EasyEPlanner.sln** для Visual Studio  содержит в себе **5** проектов:
1. **Aga.Controls** - проект UI элемента управления.
2. **EasyEPlanner** - основной проект дополнения для Eplan.
3. **EasyEplanner.Tests** - проект с юнит-тестами для дополнения. Используется NUnit, как фреймворк и Mock библиотека, как создатель Mock и Stub объектов. Stub - содержат только состояние, а Mock - поведение. Fake объект - содержит в себе и поведение, и состояние (*почитайте теорию*).
4. **EplanIdleTimeModule** - модуль простоя Eplan. Используется как отдельно, так и как часть EasyEPlanner.
5. **ObjectListView2012** - проект UI элемента управления для редактора технологических объектов.

Все проекты написаны на языке **C#** с применением технологии **.Net Framework** версии **4.5** (*Aga.Controls, ObjectListView2012*), версии **4.7.2** (*EasyEPlanner*) и версии **.Net Core 3.1** (*EasyEplanner.Tests*). Дополнительно в проекте **EasyEPlanner** используется скриптовый язык **Lua**.

Проекты **1**, **4** и **5** используется в **EasyEPlanner** как подмодули (*submodules*).

### 1.1 Aga.Controls ###

Проект содержит в себе UI-компонент, который используется в EasyEPlanner в окнах, открывающихся через пункты меню: "**Устройства, параметры объектов**" и "**Операции, ограничения и привязка объектов**".

Сам проект не нужно постоянно собирать и подписывать строгим именем т.к. он уже был собран и используется в EasyEPlanner через ссылку на dll-библиотеку(_папка libs_). При Debug или Release сборке решения он будет собираться по необходимости, но копироваться будет версия из папки libs, которая уже подписана и используется и при её замене никаких сайд эффектов быть не должно.

### 1.2 EasyEPlanner ###

Основной проект решения Visual Studio. Более подробное описание функционала можно найти в пользовательской документации. Используется в основном для описания управляющей программы для ПЛК. Описание загружается и сохраняется из **Lua** кода. Для взаимодействия с **EPLAN** используется **EPLAN API**. Надстройка может выгружать Excel отчеты, генерировать XML описание базы каналов для SCADA, считывать информацию с схем автоматизации (устройства, плк), а также поддерживает привязку каналов устройств к клеммам модулей-ввода вывода и др. Более подробно в пользовательской документации.

### 1.3 EasyEplanner.Tests ###

Проект с unit-tests, использует **EasyEPlanner** как ссылку, для тестирования. Написаны на .Net Core 3.1, но **ВНИМАНИЕ**, тесты не полностью покрывают тестами надстройку. Нужно каждый раз запускать тесты, после внесения изменений, а после, для нового функционала - писать новые, которые покрывают сценарии использования функционала. Юнит-тесты именуются по конвенции, из названий методов можно примерно понять, что они тестируют, и какой результат будет на выходе.

Конвенция нейминга - *UnitOfWork_StateUnderTest_ExpectedBehavior*. Но можно использовать современное и миксовать (*что, вроде как, встречается в коде*).

### 1.4 EplanIdleTimeModule ####

Проект модуля простоя **EPLAN**. Суть: по достижении определенного времени (*настраивается в конфигурации*), если пользователь не пользовался системой (*заблокировал компьютер через Win + L или что-то ещё*), то **EPLAN** будет выключен т.к лицензий конечное количество, а пользователей гораздо больше, чем лицензий (*иногда свободны все лицензии, а иногда нужно ждать, когда освободится*).

Надстройка может подключаться отдельно от **EasyEplanner**, так и использоваться в **EasyEplanner** (_используешь её как ссылку и получаешь доступ к классам, возможность запускать модуль и подписаться на события_). Не рекомендуется использовать одновременно в описанных случаях т.к неизвестны последствия.

### 1.5 ObjectListView2012 ###

Проект UI-компонента, использующегося в EasyEPlanner для окна "**Редактировать технологические объекты**". Сборка и использование - аналогично пункту [1.1 Aga.Controls](#1.1-Aga.Controls).

## 2. Файловая структура ##

В большинстве случаев, файлы исходного кода прокомментированы через _summary_ нотацию, что облегчает изучение кода, но иногда комментарий может быть обманчив (_легаси_). **Lua** скрипты в своем большинстве тоже прокомментированы.

### 2.1 Файловая структура готовой для использования надстройки ###

Не все файлы создаются сразу приложением, некоторые копируются из других проектов. К примеру - описание технологических объектов, но об этом ниже.

#### 2.1.1 Корневой каталог ####

<p align="center"><img src="images/eplanner-folder.png" /></p>
<p align="center">Рисунок - Общий вид каталога надстройки</p>

Описание:
1. CMD - скрипты в **.txt** формате, которые используются для проверки наличия установленного **Lua**, а также для запуска автоматического тестирования проектов.
2. Documentation - документ для настройки **Lua** в системе, чтобы работало тестирование проекта **EPLAN**.
3. Lua - вспомогательные скрипты (*описано ниже*), а также описание базовых объектов из репозитория **ptusa-lua-diary-sys**.
4. LuaInterface - подписанные библиотеки для работы с **Lua** через **C#** код и наоборот. Дублируются библиотеки *LuaInterface* и *KopiLua* из корня каталога (*легаси код, не переделывал*).
5. Aga.Controls.dll - подписанная библиотека с UI-элементом [1.1 Aga.Controls](#1.1-Aga.Controls).
6. configuration.ini - файл конфигурации для **EasyEPlanner**. Генерируется автоматически, если отсутствует, а потом в него уже записываются настройки. Описан в следующем разделе.
7. EPLAN.EplAddin.EasyEPlanner.dll - основная подписанная библиотека надстройки. Именно этот файл всегда подключается к **EPLAN**. В основном, когда вносятся изменения в проект, то чаще всего, этот файл меняется, а другие файлы остаются неизменными.
8. EPLAN.EplAddin.IdleTimeModule.dll - подписанная библиотека модуля простоя.
9. EPLAN.EplAddin.IdleTimeModule.dll.config - файл конфигурации модуля простоя. Формат - XML. Описан в следующем разделе.
10. KopiLua и LuaInterface - смотри пункт 4.
11. ObjectListView - аналогично с пунктом 5, только для [1.5 ObjectListView2012](#1.5-ObjectListView2012).
12. Spire.License, Spire.Pdf, Spire.XLS - библиотеки, использующиеся для генерации **Excel** отчетов.

#### 2.1.2 Каталог CMD ####

<p align="center"><img src="images/cmd-folder.png" /></p>
<p align="center">Рисунок - Каталог CMD</p>

Описание:
1. TestLuaAvailability.txt - скрипт для проверки наличия **Lua** в системе. Запускается процессом из EasyEPlanner.
2. TestProjectScript.txt - скрипт, запускающий тестирование после проверки наличия **Lua** в системе.

#### 2.1.3 Каталог Lua ####

<p align="center"><img src="images/lua-folder.png" /></p>
<p align="center">Рисунок - Каталог Lua</p>

Описание:
1. BaseObjectsDescriptionFiles - каталог с описанием базовых объектов. Берется из репозитория **ptusa-lua-diary-system**. Если файлов нет - будет автоматически создан вместе с начальным пустым описанием.
2. mainPattern.plua - шаблон файла **main.plua**, можно менять в реалтайме. Генерируется **1** раз, при создании проекта (_часто пользователи копируют файлы проекта и сам проект, а потом просто переделывают, поэтому генерируется редко, но иногда нужно, чтобы шаблон менялся_).
3. sys.lua - файл с **Lua** скриптами, которые загружают описание из **Lua** файлов, в частности, технологических объектов проекта в надстройку. Меняется довольно часто, когда меняется структура **Lua** файлов.
4. sys_base_objects_initializer.lua - скрипт, которые инициализирует базовые объекты, считываемые из папки (_см. пункт 1_). Меняется в зависимости от изменений базовых объектов.
5. sys_device_mock_generator.lua - скрипт делающий затычки для устройств, когда настраивается межпроектный обмен сигналами (_см. пользовательскую документацию_). При добавлении в EasyEPlanner нового устройства (_но не подтипа уже существующего устройства_), нужно обязательно добавить генерирование заглушки для него, иначе будет ошибка при загрузке межпроектного обмена.
6. sys_interproject_io.lua - скрипт чтения описания **Lua** с файла *main.io.lua* для загрузки межпроектного обмена сигналами.
7. sys_io.lua - скрипт с описанием модулей-ввода вывода, которые поддерживаются надстройкой. ПЛК зашиты в исходном коде (_легаси_).
8. sys_iolink_devices.lua - скрипт с описанием поддерживаемых IO-Link устройств.
9. sys_restriction.lua - скрипт читающий описание ограничений для технологических объектов (*всегда запускается после sys.lua*).
10. sys_shared_initializer.lua - скрипт читающий межпроектный обмен из файла *main.shared.lua* проекта.

#### 2.1.4 Каталог BaseObjectsDescriptionFiles ####

Нужно немного рассказать о том, как это работает. Базовые объекты могут быть любые, и их может быть любое количество. Главное, чтобы в файлах они не пересекались. Надстройка загружает из каждого файла базовые объекты, поэтому можно разделить их по разным критериям и использовать так, как надо пользователю. В этой папке всегда должен быть файл с описанием, иначе могут слететь в проектах базовые объекты со всеми настройками. В **SVN** репозитории файл зафиксирован (*sys_base_objects_description.lua*), который используется АСУТП. Если файла нет, то он будет создан автоматически, а внутри его будет базовое описание и комментарии о том, как заполнять этот файл. Дополнительно можно в папке Lua посмотреть файл **sys_base_object_initializer.lua**, которые показывает, что читается, и куда отправляется.

<p align="center"><img src="images/base-objects-folder.png" /></p>
<p align="center">Рисунок - Каталог BaseObjectsDescriptionFiles в каталоге Lua</p>

### 2.2 Описание файла configuration.ini и EPLAN.EplAddin.IdleTimeModule.dll.config ###

Файл configuration.ini относится к EasyEplanner, а второй, как видно из названия раздела, к модулю простоя.

#### 2.2.1 Файл конфигурации EasyEPlanner ####
Конфигурирует надстройку EasyEPlanner.

Может содержать 6 секций:
1. path - указываются пути (`folder_path` тэг) к файлам **Lua** с проектами (_есть в пользовательской документации_). Меняется руками.
2. helpSystem - указывается `address` и `mainAddress` для OSTIS (_никем не используется, но нужно было зачем-то добавить_). Меняется руками.
3. TestSettings - включение и выключение тестирование проекта (*есть в пользовательской документации*). Меняется руками.
4. currProjDevList - настройка отображения устройств для настройки межпроектного обмена в открытом проекте. Меняется автоматически.
5. advProjDevList - аналогично пункту 4, только для связываемого проекта.
6. bindedSignalsList - настройка окна связанных сигналов для межпроектного обмена. Меняется автоматически.

Пункты **4-6** используются для одного UI элемента управления в межпроектном обмене сигналами.

#### 2.2.2 Файл конфигурации модуля простоя ####

Конфигурирует модуль простоя. Конфигурация описана в формате **XML**.

Секции:
1. checkIntervalSec - интервал проверки простоя системы в секундах. Меняется руками.
2. maxChecksCount - количество успешных проверок подряд (*когда система простаивает*), после которого запускается механизм оповещения пользователя и затем отключения **EPLAN**, если пользователь не отреагировал в течении **1** минуты. Меняется руками.

### 2.3 Файлы проектов Aga.Controls и ObjectListView2012 ###

Описывать нет смысла т.к используются уже подписанными библиотеками из папки `libs`. Мы их никак не меняли пока что.

### 2.4 Файлы проекта EplanIdleTimeModule ###

Проект достаточно прост. Закрывать EPLAN, если система простаивает какое-то время. Если открыты какие либо всплывающие окна в EPLAN, то проект не может быть закрыт и тогда процесс EPLAN уничтожается через `Kill` метод процесса.

Надстройка сама по себе меняется редко, но в проекте EasyEPlanner ссылка указана на проект, а не на библиотеку. При сборке и подписи надо указывать ссылку на подписанную библиотеку (*будет описано в главе 3*).

Проект использует **Win32** библиотеки `PIInvoke`.

<p align="center"><img src="images/idle-time-module-project.png" /></p>
<p align="center">Рисунок - Структура файлов проекта IdleTimeModule</p>

Описание:
1. EplanHelper - содержит классы и интерфейсы для абстрагирования от **API** Eplan. Класс EplanHelper использует классы и интерфейсы **EplanProject** и **EplanSelectionSet**. В классах идет работа с **API** для захвата проекта и его закрытия через **API** (_если это возможно_).
2. Key - ключи для подписывания надстройки.
3. AddInModule.cs - точка входа в надстройку. Когда надстройка подключается через Eplan **API** (т.е **EPLAN** загружает её, а **EasyEplanner**), то всегда вызываются методы этого класса, реализующего интерфейс `IEplAddin` (_см. подробнее в документации к API_).
4. App.config - файл конфигурации, который затем трансформируется в _EPLAN.EplAddin.EplanIdleTimeModule.dll.config_.
5. IdleTimeModule.cs - основной класс и интерфейс, который отвечает за модуль простоя. Позволяет запустить, остановить модуль, а также закрыть приложение/проект, показывать предупреждение пользователю и др.
6. IdleTimeModuleForm.cs - форма, показываемая пользователю, когда надо подтвердить действие, либо будет закрыт EPLAN.
7. ModuleConfiguration.cs - класс и интерфейс для работы с конфигурацией модуля простоя, её чтение, копирование.
8. PInvokeUtil.cs - класс утилит Win32.
9. RunningProcess.cs - класс и интерфейс для работы с запущенным процессом (_обертка_).

Как работает? Два пути. Первый - это самостоятельное использование надстройки. Для этого нам нужен файл config и dll модуля. Можем подключить через EPLAN и наслаждаться. В этом случае, будет вход через `AddInModule.cs`. Второй - использование в EPLAN. Подключаем ссылку, используем класс IdleTimeModule.

### 2.5 Файлы проекта EasyEPlanner ###

Рассмотрение начнем с каталогов т.к проект разбит на большое количество файлов и каталогов по логическому и предметному принципу.

#### 2.5.1 Корень проекта ####


<p align="center"><img src="images/eplanner-root-project.png" /></p>
<p align="center">Рисунок - Корень проекта</p>

Каталоги `CMD`, `LuaInterface`, `Lua` (*без описания базовых объектов*) [аналогичны вот этому](#2.1.1-Корневой-каталог).

Описание:
1. Resources.resx и папка Resources - содержит ресурсы проекта. В основном это строковые шаблоны и картинки для редактора технологических объектов.
2. AssemblyInfo.cs - базовая информация о компилируемой библиотеке. Здесь меняется версия `dll`.
3. Configuration - файлы классов и интерфейсов настройки/чтения конфигурации проекта, надстройки и др. Описаны ниже.
4. Device - файлы с классами и интерфейсами для работы с устройствами, типами устройств, и др.
5. Editor - файлы с классами, интерфейсами и формами редактора технологических объектов с функционалом импорта и экспорта, подсветки устройств на ФСА и др.
6. EProjectManager - файлы с классами и интерфейсами, которые переопределены из **Eplan API**, для управления **Eplan** и проектом.
7. FileSavers - файлы с классами. интерфейсами, которые используются для сохранения различной информации. Это генерация отчета **Excel**, генерация базы каналов для **SCADA**, сохранение статистики по проекту в **SVG**, а также сохранение файлов проекта в **Lua**.
8. InterprojectExchange - полная функциональность межпроектного обмена сигналами.
9. IO - файлы с классами и интерфейсами для модулей-ввода вывода и взаимодействия с ними (привязка устройств, расчет адресного пространства в т.ч. и для IO-Link).
10. key - ключи для подписи надстройки.
11. Logs - файлы для работы с логгером проекта для пользователя. Логгер показывает пользователю подсказки и ошибки. Иногда в логгер может попадать StackTrace, если словили необработанную ошибку.
12. Main - файлы с `Action` (*см. Eplan Api документацию*), а также входным классом, который вызывается **Eplan Api** при загрузке надстройки.
13. StaticHelper - общие классы, содержащие данные и поведение, которое используется почти по всему проекту или в каком-то большом пуле классов. Все классы там статические.
14. TechObject - файлы описывающие объектную модель технологических объектов (*основной столп, как и устройства, который описывает программу в ПЛК*).
15. DeviceBindFromForm.cs - класс, отвечающий за привязку выбранного на форме устройств канала ввода-вывода к каналу ввода-вывода на модуле ввода-вывода (*привязка канала устройства к модулю плк*). Создается класс с требуемыми аргументами в конструкторе, и вызывается метод `Bind()`. На форме устройств должен быть выбран канал ввода вывода (*дабл кликом происходит срабатывание этого функционала*).
16. DFrm.cs - форма в которой происходит привязка устройств к модулям ввода-вывода, к технологическим объектам (*устройства в операции*), а также привязка параметров к технологическим объектам, где это допустимо (*см. пользовательскую документацию*).
17. EncodingDetector.cs - говорящее название. При открытии проекта проверяет кодировку его файлов и читает их в нужной кодировке, чтобы не было битых символов (**ASCII отличается от UTF-8**).
18. ModeFrm.cs - форма на которой отображаются операции технологических объектов, а также есть возможность привязки объектов друг к другу и настройка их ограничений (_ограничение включений операций_).
19. ModulesBindingUpdater.cs - класс отвечающий за обновление комментариев и привязанных устройств при их изменении. Как работает - смотри пользовательскую документацию. Под капотом: устройства всегда имеют одну и ту же ссылку, поэтому при переименовании устройства, она не меняется и мы знаем, что надо поменять. Функциональность менялась буквально пару раз когда-то давно.
20. PInvokeUtil.cs - класс с загруженными в доступ **Win32** методами и свойствами. Нужно для захвата окон т.к наши UI компоненты рисуются в **Eplan** окнах, а также для записи `.ini` конфигурации и перехвата пользовательского ввода для его обработки.
21. ProjectManager.cs - класс менеджера открытого в Eplan проекта. Через него (когда он был вызван из `Action`) происходит запуск загрузки файлов проекта, их сохранение, запуск генерации отчетов, инициализация начальная надстройки и др.

#### 2.5.2 каталог Configuration ####

Содержит классы, которые отвечают за проверку конфигурации, её чтение, синхронизацию и др. Более подробно ниже.

1. ConfigurationChecker.cs - проверяет на ошибки текущий открытый проект. Перебирает IP-адреса, проверяет устройства, модули ввода-вывода, технологические объекты, а также запускает тестирование проекта, если оно включено. Потом выводит ошибки в лог пользователя, `Logs` каталог. Основной метод внутри объектов - это `Check()` он практически всегда перегружен `override` или виртуальный `virtual` т.к все объекты технологические наследуются от `TreeViewItem`, реализующего `ITreeViewItem`, а устройства от `IDevice` и так далее по иерархии наследования.
2. DeviceBindingReader.cs - читает привязку устройств к модулям ввода-вывода со схем. Запускается из `ProjectManager`. Использует Eplan Api, устройства, модули ввода-вывода и `StaticHelper`.
3. DeviceReader.cs - читает устройства с ФСА. Использует Eplan Api, устройства. Считывает, записывает в список, которым потом пользуются другие классы.
4. DeviceSynchronizer.cs и DeviceSynchronizerService.cs - классы отвечающие за синхронизацию устройств. Когда,к примеру, переименовали устройство, и это надо обновить в разных местах, где оно используется. Когда используются устройства внутри параметров устройств других, то они не синхронизируются т.к записаны в виде строки.
5. IOReader.cs - считывает конфигурацию ПЛК и модулей ввода-вывода со схем, которая затем используется в надстройке.
6. ProjectConfiguration.cs - общий класс-обертка, который управляет всей конфигурацией. Можно запустить проверку ошибок, чтение привязки, устройств, плк и модулей ввода-вывода и синхронизацию устройств.
7. ProjectHealthChecker.cs - класс, тестирующий работоспособность проекта, запуска скрипты тестирования и выводя лог пользователю. Именно этот класс использует скрипты из папки `CMD`.

#### 2.5.3 каталог Device ####

Каталог содержит все, что связано с устройствами. Классы устройств, вспомогательные классы для более чистого создания устройств, и менеджер для работы с ними.

1. каталог IODevices - содержит перечень классов устройств, которые поддерживают ввод-вывод (_это для всех используемых устройств_). Устройства `DEV_VTUG` или `Y` - пневмоостров, который существует только в надстройке, но в файлы контроллера информация о них не грузится. Каждый класс отвечает за конкретное устройство со своими подтипами, параметрами и другими настройками. Описание у всех имеет примерно тот же алгоритм т.к они наследуются от класса `IODevice`, а тот в свою очередь от `Device`.
2. Device.cs - интерфейс и класс самого базового устройства. Содержит общую низкоуровневую логику.
3. IODevice.cs - интерфейс и класс, наследуемый от `Device`, содержит логику устройства, как устройства ввода-вывода с добавлением каналов, параметров, свойств и др. От класса `Device` кроме этого класса никто не наследуется. Также в этом файле написана реализация класса `IOChannel`, который представляет канал устройства ввода-вывода и `IOLinkSizes`, который нужен для представления размеров областей ввода-вывода устройств.
4. Parameter.cs, Property.cs, Tag.cs, RuntimeParameter.cs - частичные классы `IODevice`, которые содержат в себе классы с данными о параметрах, свойствах, тэгах и рантайм параметрах. Используются для конфигурации устройств в классах папки `IODevices` т.е помогают описать устройство без дублирования кода.
5. DeviceType.cs, DeviceSubType.cs - перечисления со всеми возможными типами и подтипами для описания устройств при описании их классов. **Важно**: номер, которые указывается в перечислении очень важен и можно добавлять только в конец т.к это влияет ещё и на контроллер.
6. DeviceManager.cs - основной класс, работающий с устройствами. Можно запустить проверки, генерацию вспомогательных данных для отчетов **Excel**, для базы каналов в **SCADA**, создание устройств, добавление, поиск, сохранение в **Lua** формат и др.

#### 2.5.4 каталог Editor ####

#### 2.5.5 каталог EProjectManager ####

Каталог содержит вспомогательные классы, которые работают с **Eplan Api**. С помощью этих классов происходит подписка на события, интеракции **EPLAN** и их обработка.

1. EplanEventListener.cs - класс с подпиской на основные главные события **EPLAN**. Такие как, открытие проекта, закрытие проекта, запуск **EPLAN**, закрытие **EPLAN** и др. Из этого класса в основном запускается сохранение проекта в **Lua** (_кроме этого, это можно сделать ещё из редактора объектов, а также через окно с устройствами)_, и его загрузка через `ProjectManager`.
2. EProjectManager.cs - созвучен с `ProjectManager`, но имеет приставку `E`. Реализует базовую логику, которая требует взаимодействия с Eplan API. Включение/отключение режима редактирования в редакторе, чтобы можно было добавлять устройства в операцию объекта через клик по нему на ФСА. Содержит логику сохранения и загрузки файлов проекта, которые вызываются в `EplanEventListener`.
3. InsertMacrosInteraction.cs - переопределенная пользовательская интеракция, которая вызывается тогда, когда в EPLAN происходит внутренняя интеракция XMaInsertMacro (проверка интеракции в Eplan может произойти через Ctrl + \ - это справа от буквы `э` на клавиатуре. В том окошке видны последние действия и запущены ли интеракции).
4. SelectInteractionWhileEditModes.cs - интеракция, которая включается, когда включается режим редактирования, при каждом клике на ФСА она пытается распознать устройство. Если распознано - добавляет его в выбранный пункт в редакторе объектов (_если это не противоречит бизнес-логике_), а затем перезапускает саму себя, пока в редакторе включен режим редактирования. При переключении между страницами интеракция перезапускается т.к внутренний механизм EPLAN её сбрасывает.

#### 2.5.6 каталог FileSavers ####
#### 2.5.7 каталог InterprojectExchange ####
#### 2.5.8 каталог IO ####
#### 2.5.9 каталог Logs ####
#### 2.5.10 каталог Main ####
#### 2.5.11 каталог StaticHelper ####
#### 2.5.12 каталог TechObject ####
#### 2.5.13 ####

### 2.6 Файлы проекта EasyEplanner.Tests ###

Структура файлов аналогично EasyEPlanner, только к каждой папке, классу есть приписка .Tests, которая обозначает, что файл с юнит тестами. Это просто конвенция нейминга, и ни на что она не влияет.

## 3. Сборка проекта и подписывание библиотек ключом EPLAN ##

### 3.1 Сборка через терминал ###

### 3.2 Сборка через Visual Studio ###

## Возможные изменения, вопросы пользователей ##