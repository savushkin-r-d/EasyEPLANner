# Руководство начинающего разработчика для EasyEPlanner #

Данное руководство служит новичкам для ознакомления с решением и углубления знаний в проекте без непосредственного исследования кода. Помимо этого руководства, желательно ещё изучить руководство пользователя т.к позволяет изучить варианты использования системы пользователями, а также пользовательский функционал.

**Примечание**: надстройка работает только с одним открытым проектом в EPLAN.

Дополнение подключается к версии **EPLAN 2.8** (*сейчас 2.9*) и новее.

[Пользовательская документация](https://github.com/savushkin-r-d/EasyEPLANner/tree/master/docs/user_manual).

[Документация по API](https://www.eplan.help/en-US/infoportal/content/api/2.9/index.html).
## Содержание ##
1-Технологический-стек-и-проекты

## 1. Технологический стек и проекты ##

Решение **EasyEPlanner.sln** для Visual Studio  содержит в себе **5** проектов:
1. **Aga.Controls** - проект UI элемента управления.
2. **EasyEPlanner** - основной проект дополнения для Eplan.
3. **EasyEplanner.Tests** - проект с юнит-тестами для дополнения. Используется NUnit, как фреймворк и Mock библиотека, как создатель Mock и Stub объектов. Stub - содержат только состояние, а Mock - поведение. Fake объект - содержит в себе и поведение, и состояние (*почитайте теорию*).
4. **EplanIdleTimeModule** - модуль простоя Eplan. Используется как отдельно, так и как часть EasyEPlanner.
5. **ObjectListView2012** - проект UI элемента управления для редактора технологических объектов.

Все проекты написаны на языке **C#** с применением технологии **.Net Framework** версии **4.5** (*Aga.Controls, ObjectListView2012*), версии **4.7.2** (*EasyEPlanner*) и версии **.Net Core 3.1** (*EasyEplanner.Tests*). Дополнительно в проекте **EasyEPlanner** используется скриптовый язык **Lua**.

Проекты **1**, **4** и **5** используется в **EasyEPlanner** как подмодули (*submodules*).

### 1.1 Aga.Controls ###

Проект содержит в себе UI-компонент, который используется в EasyEPlanner в окнах, открывающихся через пункты меню: "**Устройства, параметры объектов**" и "**Операции, ограничения и привязка объектов**".

Сам проект не нужно постоянно собирать и подписывать строгим именем т.к. он уже был собран и используется в EasyEPlanner через ссылку на dll-библиотеку(_папка libs_). При Debug или Release сборке решения он будет собираться по необходимости, но копироваться будет версия из папки libs, которая уже подписана и используется и при её замене никаких сайд эффектов быть не должно.

### 1.2 EasyEPlanner ###

Основной проект решения Visual Studio. Более подробное описание функционала можно найти в пользовательской документации. Используется в основном для описания управляющей программы для ПЛК. Описание загружается и сохраняется из **Lua** кода. Для взаимодействия с **EPLAN** используется **EPLAN API**. Надстройка может выгружать Excel отчеты, генерировать XML описание базы каналов для SCADA, считывать информацию с схем автоматизации (устройства, плк), а также поддерживает привязку каналов устройств к клеммам модулей-ввода вывода и др. Более подробно в пользовательской документации.

### 1.3 EasyEplanner.Tests ###

Проект с unit-tests, использует **EasyEPlanner** как ссылку, для тестирования. Написаны на .Net Core 3.1, но **ВНИМАНИЕ**, тесты не полностью покрывают тестами надстройку. Нужно каждый раз запускать тесты, после внесения изменений, а после, для нового функционала - писать новые, которые покрывают сценарии использования функционала. Юнит-тесты именуются по конвенции, из названий методов можно примерно понять, что они тестируют, и какой результат будет на выходе.

Конвенция нейминга - *UnitOfWork_StateUnderTest_ExpectedBehavior*. Но можно использовать современное и миксовать (*что, вроде как, встречается в коде*).

### 1.4 EplanIdleTimeModule ####

Проект модуля простоя **EPLAN**. Суть: по достижении определенного времени (*настраивается в конфигурации*), если пользователь не пользовался системой (*заблокировал компьютер через Win + L или что-то ещё*), то **EPLAN** будет выключен т.к лицензий конечное количество, а пользователей гораздо больше, чем лицензий (*иногда свободны все лицензии, а иногда нужно ждать, когда освободится*).

Надстройка может подключаться отдельно от **EasyEplanner**, так и использоваться в **EasyEplanner** (_используешь её как ссылку и получаешь доступ к классам, возможность запускать модуль и подписаться на события_). Не рекомендуется использовать одновременно в описанных случаях т.к неизвестны последствия.

### 1.5 ObjectListView2012 ###

Проект UI-компонента, использующегося в EasyEPlanner для окна "**Редактировать технологические объекты**". Сборка и использование - аналогично пункту [1.1 Aga.Controls](#11-AgaControls).

## 2. Файловая структура ##

В большинстве случаев, файлы исходного кода прокомментированы через _summary_ нотацию, что облегчает изучение кода, но иногда комментарий может быть обманчив (_легаси_). **Lua** скрипты в своем большинстве тоже прокомментированы.

### 2.1 Файловая структура готовой для использования надстройки ###

Не все файлы создаются сразу приложением, некоторые копируются из других проектов. К примеру - описание технологических объектов, но об этом ниже.

#### 2.1.1 Корневой каталог ####

<p align="center"><img src="images/eplanner-folder.png" /></p>
<p align="center">Рисунок - Общий вид каталога надстройки</p>

Описание:
1. CMD - скрипты в **.txt** формате, которые используются для проверки наличия установленного **Lua**, а также для запуска автоматического тестирования проектов.
2. Documentation - документ для настройки **Lua** в системе, чтобы работало тестирование проекта **EPLAN**.
3. Lua - вспомогательные скрипты (*описано ниже*), а также описание базовых объектов из репозитория **ptusa-lua-diary-sys**.
4. LuaInterface - подписанные библиотеки для работы с **Lua** через **C#** код и наоборот. Дублируются библиотеки *LuaInterface* и *KopiLua* из корня каталога (*легаси код, не переделывал*).
5. Aga.Controls.dll - подписанная библиотека с UI-элементом [1.1 Aga.Controls](#11-AgaControls).
6. configuration.ini - файл конфигурации для **EasyEPlanner**. Генерируется автоматически, если отсутствует, а потом в него уже записываются настройки. Описан в следующем разделе.
7. EPLAN.EplAddin.EasyEPlanner.dll - основная подписанная библиотека надстройки. Именно этот файл всегда подключается к **EPLAN**. В основном, когда вносятся изменения в проект, то чаще всего, этот файл меняется, а другие файлы остаются неизменными.
8. EPLAN.EplAddin.IdleTimeModule.dll - подписанная библиотека модуля простоя.
9. EPLAN.EplAddin.IdleTimeModule.dll.config - файл конфигурации модуля простоя. Формат - XML. Описан в следующем разделе.
10. KopiLua и LuaInterface - смотри пункт 4.
11. ObjectListView - аналогично с пунктом 5, только для [1.5 ObjectListView2012](#15-ObjectListView2012).
12. Spire.License, Spire.Pdf, Spire.XLS - библиотеки, использующиеся для генерации **Excel** отчетов.

#### 2.1.2 Каталог CMD ####

<p align="center"><img src="images/cmd-folder.png" /></p>
<p align="center">Рисунок - Каталог CMD</p>

Описание:
1. TestLuaAvailability.txt - скрипт для проверки наличия **Lua** в системе. Запускается процессом из EasyEPlanner.
2. TestProjectScript.txt - скрипт, запускающий тестирование после проверки наличия **Lua** в системе.

#### 2.1.3 Каталог Lua ####

<p align="center"><img src="images/lua-folder.png" /></p>
<p align="center">Рисунок - Каталог Lua</p>

Описание:
1. BaseObjectsDescriptionFiles - каталог с описанием базовых объектов. Берется из репозитория **ptusa-lua-diary-system**. Если файлов нет - будет автоматически создан вместе с начальным пустым описанием.
2. mainPattern.plua - шаблон файла **main.plua**, можно менять в реалтайме. Генерируется **1** раз, при создании проекта (_часто пользователи копируют файлы проекта и сам проект, а потом просто переделывают, поэтому генерируется редко, но иногда нужно, чтобы шаблон менялся_).
3. sys.lua - файл с **Lua** скриптами, которые загружают описание из **Lua** файлов, в частности, технологических объектов проекта в надстройку. Меняется довольно часто, когда меняется структура **Lua** файлов.
4. sys_base_objects_initializer.lua - скрипт, которые инициализирует базовые объекты, считываемые из папки (_см. пункт 1_). Меняется в зависимости от изменений базовых объектов.
5. sys_device_mock_generator.lua - скрипт делающий затычки для устройств, когда настраивается межпроектный обмен сигналами (_см. пользовательскую документацию_). При добавлении в EasyEPlanner нового устройства (_но не подтипа уже существующего устройства_), нужно обязательно добавить генерирование заглушки для него, иначе будет ошибка при загрузке межпроектного обмена.
6. sys_interproject_io.lua - скрипт чтения описания **Lua** с файла *main.io.lua* для загрузки межпроектного обмена сигналами.
7. sys_io.lua - скрипт с описанием модулей-ввода вывода, которые поддерживаются надстройкой. ПЛК зашиты в исходном коде (_легаси_).
8. sys_iolink_devices.lua - скрипт с описанием поддерживаемых IO-Link устройств.
9. sys_restriction.lua - скрипт читающий описание ограничений для технологических объектов (*всегда запускается после sys.lua*).
10. sys_shared_initializer.lua - скрипт читающий межпроектный обмен из файла *main.shared.lua* проекта.

#### 2.1.4 Каталог BaseObjectsDescriptionFiles ####

Нужно немного рассказать о том, как это работает. Базовые объекты могут быть любые, и их может быть любое количество. Главное, чтобы в файлах они не пересекались. Надстройка загружает из каждого файла базовые объекты, поэтому можно разделить их по разным критериям и использовать так, как надо пользователю. В этой папке всегда должен быть файл с описанием, иначе могут слететь в проектах базовые объекты со всеми настройками. В **SVN** репозитории файл зафиксирован (*sys_base_objects_description.lua*), который используется АСУТП. Если файла нет, то он будет создан автоматически, а внутри его будет базовое описание и комментарии о том, как заполнять этот файл. Дополнительно можно в папке Lua посмотреть файл **sys_base_object_initializer.lua**, которые показывает, что читается, и куда отправляется.

<p align="center"><img src="images/base-objects-folder.png" /></p>
<p align="center">Рисунок - Каталог BaseObjectsDescriptionFiles в каталоге Lua</p>

### 2.2 Описание файла configuration.ini и EPLAN.EplAddin.IdleTimeModule.dll.config ###

Файл configuration.ini относится к EasyEplanner, а второй, как видно из названия раздела, к модулю простоя.

#### 2.2.1 Файл конфигурации EasyEPlanner ####
Конфигурирует надстройку EasyEPlanner.

Может содержать 6 секций:
1. path - указываются пути (`folder_path` тэг) к файлам **Lua** с проектами (_есть в пользовательской документации_). Меняется руками.
2. helpSystem - указывается `address` и `mainAddress` для OSTIS (_никем не используется, но нужно было зачем-то добавить_). Меняется руками.
3. TestSettings - включение и выключение тестирование проекта (*есть в пользовательской документации*). Меняется руками.
4. currProjDevList - настройка отображения устройств для настройки межпроектного обмена в открытом проекте. Меняется автоматически.
5. advProjDevList - аналогично пункту 4, только для связываемого проекта.
6. bindedSignalsList - настройка окна связанных сигналов для межпроектного обмена. Меняется автоматически.

Пункты **4-6** используются для одного UI элемента управления в межпроектном обмене сигналами.

#### 2.2.2 Файл конфигурации модуля простоя ####

Конфигурирует модуль простоя. Конфигурация описана в формате **XML**.

Секции:
1. checkIntervalSec - интервал проверки простоя системы в секундах. Меняется руками.
2. maxChecksCount - количество успешных проверок подряд (*когда система простаивает*), после которого запускается механизм оповещения пользователя и затем отключения **EPLAN**, если пользователь не отреагировал в течении **1** минуты. Меняется руками.

### 2.3 Файлы проектов Aga.Controls и ObjectListView2012 ###

Описывать нет смысла т.к используются уже подписанными библиотеками из папки `libs`. Мы их никак не меняли пока что.

### 2.4 Файлы проекта EplanIdleTimeModule ###

Проект достаточно прост. Закрывать EPLAN, если система простаивает какое-то время. Если открыты какие либо всплывающие окна в EPLAN, то проект не может быть закрыт и тогда процесс EPLAN уничтожается через `Kill` метод процесса.

Надстройка сама по себе меняется редко, но в проекте EasyEPlanner ссылка указана на проект, а не на библиотеку. При сборке и подписи надо указывать ссылку на подписанную библиотеку (*будет описано в главе 3*).

Проект использует **Win32** библиотеки `PIInvoke`.

<p align="center"><img src="images/idle-time-module-project.png" /></p>
<p align="center">Рисунок - Структура файлов проекта IdleTimeModule</p>

Описание:
1. EplanHelper - содержит классы и интерфейсы для абстрагирования от **API** Eplan. Класс EplanHelper использует классы и интерфейсы **EplanProject** и **EplanSelectionSet**. В классах идет работа с **API** для захвата проекта и его закрытия через **API** (_если это возможно_).
2. Key - ключи для подписывания надстройки.
3. AddInModule.cs - точка входа в надстройку. Когда надстройка подключается через Eplan **API** (т.е **EPLAN** загружает её, а **EasyEplanner**), то всегда вызываются методы этого класса, реализующего интерфейс `IEplAddin` (_см. подробнее в документации к API_).
4. App.config - файл конфигурации, который затем трансформируется в _EPLAN.EplAddin.EplanIdleTimeModule.dll.config_.
5. IdleTimeModule.cs - основной класс и интерфейс, который отвечает за модуль простоя. Позволяет запустить, остановить модуль, а также закрыть приложение/проект, показывать предупреждение пользователю и др.
6. IdleTimeModuleForm.cs - форма, показываемая пользователю, когда надо подтвердить действие, либо будет закрыт EPLAN.
7. ModuleConfiguration.cs - класс и интерфейс для работы с конфигурацией модуля простоя, её чтение, копирование.
8. PInvokeUtil.cs - класс утилит Win32.
9. RunningProcess.cs - класс и интерфейс для работы с запущенным процессом (_обертка_).

Как работает? Два пути. Первый - это самостоятельное использование надстройки. Для этого нам нужен файл config и dll модуля. Можем подключить через EPLAN и наслаждаться. В этом случае, будет вход через `AddInModule.cs`. Второй - использование в EPLAN. Подключаем ссылку, используем класс IdleTimeModule.

### 2.5 Файлы проекта EasyEPlanner ###

Рассмотрение начнем с каталогов т.к проект разбит на большое количество файлов и каталогов по логическому и предметному принципу.

#### 2.5.1 Корень проекта ####


<p align="center"><img src="images/eplanner-root-project.png" /></p>
<p align="center">Рисунок - Корень проекта</p>

Каталоги `CMD`, `LuaInterface`, `Lua` (*без описания базовых объектов*) [аналогичны вот этому](#211-Корневой-каталог).

Описание:
1. Resources.resx и папка Resources - содержит ресурсы проекта. В основном это строковые шаблоны и картинки для редактора технологических объектов.
2. AssemblyInfo.cs - базовая информация о компилируемой библиотеке. Здесь меняется версия `dll`.
3. Configuration - файлы классов и интерфейсов настройки/чтения конфигурации проекта, надстройки и др. Описаны ниже.
4. Device - файлы с классами и интерфейсами для работы с устройствами, типами устройств, и др.
5. Editor - файлы с классами, интерфейсами и формами редактора технологических объектов с функционалом импорта и экспорта, подсветки устройств на ФСА и др.
6. EProjectManager - файлы с классами и интерфейсами, которые переопределены из **Eplan API**, для управления **Eplan** и проектом.
7. FileSavers - файлы с классами. интерфейсами, которые используются для сохранения различной информации. Это генерация отчета **Excel**, генерация базы каналов для **SCADA**, сохранение статистики по проекту в **SVG**, а также сохранение файлов проекта в **Lua**.
8. InterprojectExchange - полная функциональность межпроектного обмена сигналами.
9. IO - файлы с классами и интерфейсами для модулей-ввода вывода и взаимодействия с ними (привязка устройств, расчет адресного пространства в т.ч. и для IO-Link).
10. key - ключи для подписи надстройки.
11. Logs - файлы для работы с логгером проекта для пользователя. Логгер показывает пользователю подсказки и ошибки. Иногда в логгер может попадать StackTrace, если словили необработанную ошибку.
12. Main - файлы с `Action` (*см. Eplan Api документацию*), а также входным классом, который вызывается **Eplan Api** при загрузке надстройки.
13. StaticHelper - общие классы, содержащие данные и поведение, которое используется почти по всему проекту или в каком-то большом пуле классов. Все классы там статические.
14. TechObject - файлы описывающие объектную модель технологических объектов (*основной столп, как и устройства, который описывает программу в ПЛК*).
15. DeviceBindFromForm.cs - класс, отвечающий за привязку выбранного на форме устройств канала ввода-вывода к каналу ввода-вывода на модуле ввода-вывода (*привязка канала устройства к модулю плк*). Создается класс с требуемыми аргументами в конструкторе, и вызывается метод `Bind()`. На форме устройств должен быть выбран канал ввода вывода (*дабл кликом происходит срабатывание этого функционала*).
16. DFrm.cs - форма в которой происходит привязка устройств к модулям ввода-вывода, к технологическим объектам (*устройства в операции*), а также привязка параметров к технологическим объектам, где это допустимо (*см. пользовательскую документацию*).
17. EncodingDetector.cs - говорящее название. При открытии проекта проверяет кодировку его файлов и читает их в нужной кодировке, чтобы не было битых символов (**ASCII отличается от UTF-8**).
18. ModeFrm.cs - форма на которой отображаются операции технологических объектов, а также есть возможность привязки объектов друг к другу и настройка их ограничений (_ограничение включений операций_).
19. ModulesBindingUpdater.cs - класс отвечающий за обновление комментариев и привязанных устройств при их изменении. Как работает - смотри пользовательскую документацию. Под капотом: устройства всегда имеют одну и ту же ссылку, поэтому при переименовании устройства, она не меняется и мы знаем, что надо поменять. Функциональность менялась буквально пару раз когда-то давно.
20. PInvokeUtil.cs - класс с загруженными в доступ **Win32** методами и свойствами. Нужно для захвата окон т.к наши UI компоненты рисуются в **Eplan** окнах, а также для записи `.ini` конфигурации и перехвата пользовательского ввода для его обработки.
21. ProjectManager.cs - класс менеджера открытого в Eplan проекта. Через него (когда он был вызван из `Action`) происходит запуск загрузки файлов проекта, их сохранение, запуск генерации отчетов, инициализация начальная надстройки и др.

#### 2.5.2 каталог Configuration ####

Содержит классы, которые отвечают за проверку конфигурации, её чтение, синхронизацию и др. Более подробно ниже.

1. ConfigurationChecker.cs - проверяет на ошибки текущий открытый проект. Перебирает IP-адреса, проверяет устройства, модули ввода-вывода, технологические объекты, а также запускает тестирование проекта, если оно включено. Потом выводит ошибки в лог пользователя, `Logs` каталог. Основной метод внутри объектов - это `Check()` он практически всегда перегружен `override` или виртуальный `virtual` т.к все объекты технологические наследуются от `TreeViewItem`, реализующего `ITreeViewItem`, а устройства от `IDevice` и так далее по иерархии наследования.
2. DeviceBindingReader.cs - читает привязку устройств к модулям ввода-вывода со схем. Запускается из `ProjectManager`. Использует Eplan Api, устройства, модули ввода-вывода и `StaticHelper`.
3. DeviceReader.cs - читает устройства с ФСА. Использует Eplan Api, устройства. Считывает, записывает в список, которым потом пользуются другие классы.
4. DeviceSynchronizer.cs и DeviceSynchronizerService.cs - классы отвечающие за синхронизацию устройств. Когда,к примеру, переименовали устройство, и это надо обновить в разных местах, где оно используется. Когда используются устройства внутри параметров устройств других, то они не синхронизируются т.к записаны в виде строки.
5. IOReader.cs - считывает конфигурацию ПЛК и модулей ввода-вывода со схем, которая затем используется в надстройке.
6. ProjectConfiguration.cs - общий класс-обертка, который управляет всей конфигурацией. Можно запустить проверку ошибок, чтение привязки, устройств, плк и модулей ввода-вывода и синхронизацию устройств.
7. ProjectHealthChecker.cs - класс, тестирующий работоспособность проекта, запуска скрипты тестирования и выводя лог пользователю. Именно этот класс использует скрипты из папки `CMD`.

#### 2.5.3 каталог Device ####

Каталог содержит все, что связано с устройствами. Классы устройств, вспомогательные классы для более чистого создания устройств, и менеджер для работы с ними.

1. каталог IODevices - содержит перечень классов устройств, которые поддерживают ввод-вывод (_это для всех используемых устройств_). Устройства `DEV_VTUG` или `Y` - пневмоостров, который существует только в надстройке, но в файлы контроллера информация о них не грузится. Каждый класс отвечает за конкретное устройство со своими подтипами, параметрами и другими настройками. Описание у всех имеет примерно тот же алгоритм т.к они наследуются от класса `IODevice`, а тот в свою очередь от `Device`.
2. Device.cs - интерфейс и класс самого базового устройства. Содержит общую низкоуровневую логику.
3. IODevice.cs - интерфейс и класс, наследуемый от `Device`, содержит логику устройства, как устройства ввода-вывода с добавлением каналов, параметров, свойств и др. От класса `Device` кроме этого класса никто не наследуется. Также в этом файле написана реализация класса `IOChannel`, который представляет канал устройства ввода-вывода и `IOLinkSizes`, который нужен для представления размеров областей ввода-вывода устройств.
4. Parameter.cs, Property.cs, Tag.cs, RuntimeParameter.cs - частичные классы `IODevice`, которые содержат в себе классы с данными о параметрах, свойствах, тэгах и рантайм параметрах. Используются для конфигурации устройств в классах папки `IODevices` т.е помогают описать устройство без дублирования кода.
5. DeviceType.cs, DeviceSubType.cs - перечисления со всеми возможными типами и подтипами для описания устройств при описании их классов. **Важно**: номер, которые указывается в перечислении очень важен и можно добавлять только в конец т.к это влияет ещё и на контроллер.
6. DeviceManager.cs - основной класс, работающий с устройствами. Можно запустить проверки, генерацию вспомогательных данных для отчетов **Excel**, для базы каналов в **SCADA**, создание устройств, добавление, поиск, сохранение в **Lua** формат и др.

#### 2.5.4 каталог Editor ####

#### 2.5.5 каталог EProjectManager ####

Каталог содержит вспомогательные классы, которые работают с **Eplan Api**. С помощью этих классов происходит подписка на события, интеракции **EPLAN** и их обработка.

1. EplanEventListener.cs - класс с подпиской на основные главные события **EPLAN**. Такие как, открытие проекта, закрытие проекта, запуск **EPLAN**, закрытие **EPLAN** и др. Из этого класса в основном запускается сохранение проекта в **Lua** (_кроме этого, это можно сделать ещё из редактора объектов, а также через окно с устройствами)_, и его загрузка через `ProjectManager`.
2. EProjectManager.cs - созвучен с `ProjectManager`, но имеет приставку `E`. Реализует базовую логику, которая требует взаимодействия с Eplan API. Включение/отключение режима редактирования в редакторе, чтобы можно было добавлять устройства в операцию объекта через клик по нему на ФСА. Содержит логику сохранения и загрузки файлов проекта, которые вызываются в `EplanEventListener`.
3. InsertMacrosInteraction.cs - переопределенная пользовательская интеракция, которая вызывается тогда, когда в EPLAN происходит внутренняя интеракция XMaInsertMacro (проверка интеракции в Eplan может произойти через Ctrl + \ - это справа от буквы `э` на клавиатуре. В том окошке видны последние действия и запущены ли интеракции).
4. SelectInteractionWhileEditModes.cs - интеракция, которая включается, когда включается режим редактирования, при каждом клике на ФСА она пытается распознать устройство. Если распознано - добавляет его в выбранный пункт в редакторе объектов (_если это не противоречит бизнес-логике_), а затем перезапускает саму себя, пока в редакторе включен режим редактирования. При переключении между страницами интеракция перезапускается т.к внутренний механизм EPLAN её сбрасывает.

#### 2.5.6 каталог FileSavers ####

В каталоге содержатся файлы, отвечающие за сохранение информации на диск в разных форматах, которые используются для разных нужд.

1. Excel - каталог содержащий классы отвечающие за генерацию **Excel** отчета. `ExcelReporter` генерирует отчет, а `ExcelDataCollector` - собирает данные для ExcelReporter т.е он используется в нём.
2. PrgLuaSaver.cs - класс, который отвечает за генерацию файла проекта **main.prg.lua**. Он использует менеджеры устройств и технологических объектов и в соответствии с бизнес-логикой, формирует файл как таблицу **Lua** и возвращает в виде строки классу `ProjectDescriptionSaver`.
3. ProjectDescriptionSaver.cs - класс, занимающийся сохранением всей нужной информации для ПЛК в **Lua** формате и записью в каталог с проектом. Выводит также лог, если нужно по бизнес-логике.
4. SVGStatisticsSaver.cs - сохраняет различные SVG-изображения статистики по проекту. Сколько агрегатов, аппаратов, устройств и др.
5. XMLReporter.cs и XMLReporterDialog.cs - отвечают за генерацию базы каналов для **SCADA**. С помощью формы происходят первоначальные настройки перед запуском генерации. Форма же и запускает генерацию базы каналов.

#### 2.5.7 каталог InterprojectExchange ####
#### 2.5.8 каталог IO ####

В каталоге основные классы для работы с модулями ввода-вывода.

1. IOLinkCalculator.cs - рассчитывает адресное пространство для IO-Link модулей ввода-вывода.
2. IOModule.cs - класс, описывающий модуль ввода-вывода и взаимодействие с ним. Привязку устройств к нему, генерацию разного вида частей отчета Excel, проверки правильности заполнения модуля, IO-Link адресов и др.
3. IOModuleInfo.cs - класс-описание модуля ввода-вывода с базовой логикой, для чтения этой информации и её передачи. Описание считывается из sys_io.lua.
4. IONode.cs - класс, описывающий узел ввода-вывода (*в частности, ПЛК*). В этом классе зашиты поддерживаемые узлы ввода-вывода, функции генерации описания для Lua (*обычно каждый класс, который должен быть сохранен, знает как себя сохранить*).
5. IOManager.cs - основной класс, управляющий узлами, модулями ввода-вывода. Проверка, добавление, поиск и др. Содержит описание того, какие модули являются IO-Link (*помимо sys_io.lua*).

#### 2.5.9 каталог Logs ####

Каталог содержит форму логов и логику работы с ней.

1. Logs.cs - класс работы с формой, можно добавить сообщение, очистить, управлять формой и др.
2. LogFrm.cs - форма логов. Содержит базовую логику обработки команд от `Logs`.

#### 2.5.10 каталог Main ####

Каталог, который содержит в себе входную точку в `dll` библиотеку. Из этого каталога начинается работа всей надстройки. Грубо говоря, надстройка - это куча разных `Action` из **EPLAN**, которые вызываются по каким-то событиям **EPLAN** или через пункты меню.

1. AboutProgrammAction.cs - действие "*О программе*", которое вызывается через пункт меню. Показывает текущую версию надстройки и информацию о лицензии.
2. ShowTechObjectsAction.cs - действие запуска редактирования технологических объектов с открытием редактора. Вызывается через пункт меню "*Редактировать технологические объекты*".
3. ShowOperationsAction.cs - действие запуска просмотра операций, настройки ограничений и привязки объектов для редактора технологических объектов. Открывает окно. Запускается через пункт меню "_Операции, ограничения и привязка объектов_".
4. ShowDevicesAction.cs - действия просмотра устройств, параметров объекта и их добавления в технологические объекты. Открывает окно. Запускается через пункт меню "_Устройства, параметры объектов_".
5. SaveDescriptionAction.cs - действие, которое запускает сохранение файлов проекта в **Lua** формате, а также запись статистики в **SVG**. Запускается из `EProjectManager`.
6. SaveAsXMLAction.cs - действие, запускающее экспорт базы каналов для **SCADA**. Сразу открывается окно, через которое конфигурируется экспорт. Запускается через пункт меню "*Экспорт XML для EasyServer*".
7. LoadDescriptionAction.cs - действие, запускающее чтение файлов **Lua** проекта для загрузки информации в надстройку. Запускается при открытии проекта в `EplanEventListener` и при синхронизации с сохранением в `EProjectManager`.
8. InterprojectExchangeAction.cs - действие, запускающее функционал межпроектного обмена сигналами между проектами. Открывает окно, считывает данные связанных проектов (*если есть*). Запускается через пункт меню "*Обмен сигналами между проектами*".
9. ExportTechDevsToExcelAction.cs - действие, запускающее экспорт отчета о проекте в **Excel**. Запускается через пункт меню "*Экспорт технологических устройств в Excel*". Сохраняется в файл с проектом **EPLAN**, в каталог **DOC**. Дополнительно в этом каталоге генерируется файл с припиской **auto_report**. Он генерируется каждый раз при синхронизации/сохранении файлов проекта в **Lua** и содержит урезанную информацию, которая нужна чаще, чем большой **Excel** отчет.
10. BindingSynchronizationAction.cs - действие, запускающее синхронизацию устройств и модулей ввода-вывода. Запускается через пункт меню "*Синхронизация названий устройств и модулей*".
11. AddInModule.cs - точка входа в надстройку. **EPLAN** при подключении надстройки выполняет код из этого класса. В этом классе регистрируются `Action`, настраиваются пункты меню и именно из этого класса происходит инициализация всех нужных для работы данных. Более подробно в **Eplan API**.

#### 2.5.11 каталог StaticHelper ####

Содержит общую статическую информацию, которая может использоваться по всему проекту, чтобы не дублировать код. Местами есть дублирование т.к не все переведено в эти классы (_легаси_).
1. ApiHelper.cs - класс, облегчающий работу с **Eplan Api**, инкапсулирует сложность, выдавая более простые методы. Много кода было написано ещё напрямую, поэтому если в нем нет функции, которая Вам нужна, и будет использоваться более 1 раза, то смело можно выносить их сюда. Класс статический, учитывайте это при работе с данными, которые изменяются.
2. CommonConst.cs - класс, содержащий основные константы для проекта.
3. DeviceBindingHelper.cs - класс, облегчающий привязку устройств для `DeviceBindingReader` и пары других классов.
4. GUIHelper.cs - класс, содержащий вспомогательные общие методы для работы с формами и их настройкой. Используется в основных формах надстройки.
5. IPConverter.cs - класс, который конвертирует **IP-адрес** из `string` в тип `long`.
6. LuaHelper.cs - класс для конвертирования **Lua** таблиц в типы, с которыми удобно работать в надстройке. Иногда данные приходят в виде **Lua** таблицы и с ними нельзя работать таким образом (*на самом деле можно, но лучше так не делать*), нужно конвертировать.

#### 2.5.12 каталог TechObject ####
#### 2.5.13 ####

### 2.6 Файлы проекта EasyEplanner.Tests ###

Структура файлов аналогично EasyEPlanner, только к каждой папке, классу есть приписка .Tests, которая обозначает, что файл с юнит тестами. Это просто конвенция нейминга, и ни на что она не влияет.

## 3. Сборка проекта и подписывание библиотек ключом EPLAN ##

Для того, чтобы надстройка могла быть подключена к **EPLAN**, она должна быть подписана ключами **EPLAN** и верифицирована на их сервере. Для того, чтобы можно было отлаживать надстройку, не обязательно её подписывать т.к. лицензия **EPLAN**, которая имеет компонент для разработки **API**, поддерживает неподписанные надстройки с возможностью отладки через **VS Studio**.

**Git** клиент может быть любой, я использую **TortoiseGit**, коллеги используют GitHub Desktop, GitKraken, Git Bash.

### 3.1 Сборка через терминал ###

Для этого можно использовать компилятор **msbuild**. Обязательно нужно, чтобы **submodules** были инициализированы и установлен EPLAN.

Строка для сборки: `msbuild /m /p:Configuration=<buildType> <PathTo .sln>`.

buildType - тип сборки. Указывается Debug, Release или ReleaseSigned.

PathTo .sln - это путь к файлу решения `.sln`.

Такая строка используется для сборки при **Pull Request**. Если поставить *Label* **safe to test**, то будет запущена автоматическая сборка надстройки и запуск *unit-tests*. Обычно, такой вид сборки используется только на гитхабе. Для продакшена мы используем Visual Studio Community т.к. проект Open Source, то это легально.
### 3.2 Сборка через Visual Studio ###

Для того, чтобы собрать через **Visual Studio**, надо чтобы был установлен **EPLAN**, инициализированы **submodules**, потом нажимаете кнопку сборки **F6** или в пункте меню "**Сборка**" >> "**Собрать решение**". На выходе получите файлы надстройки (_но без файла конфигурации, его можно скопировать из SVN каталога с надстройкой для пользователей, чтобы можно было проводить отладку_). Это будет дополнительно рассмотрено в пункте отладки надстройки.

### 3.3 Сборка для подписи надстройки, и её подписывание ###

Осуществляется через **VS Studio**. Рассмотрим по пунктам.

1. Необходимо изменить ссылку на **EplanIdleTimeModule** в ссылках т.к. в проекте идет ссылка на проект, но так как у нас уже есть подписанная надстройка модуля, то надо сослаться на уже подписанную надстройку в корневом каталоге надстройки, описанной в пункте [2.1.1](#211-Корневой-каталог), чтобы её не пришлось заменять и подписывать заново. Для этого надо открыть в корне проекта **"Ссылки"/"References"**, найти **EplanIdleTimeModule**, удалить его клавишей **Delete**, а затем добавить новую ссылку, указав уже подписанную надстройку из корневого каталога с надстройкой для пользователей.
2. Нужно выбрать конфигурацию сборки **ReleaseSigned**.
3. Затем, открыть настройки проекта, перейти на вкладку **"Подписывание"/"Signing"**.
4. Поставить галочку напротив **"Подписать сборку"/"Sign the assembly"**.
5. Выбрать ключ для подписи - **key/2112_Public.snk**.
6. Поставить галочку ниже, на пунктике **"Только отложенная подпись"/"Delay sign only"**.
7. Собрать надстройку через **F6** или через пункты меню **IDE**.

Затем можно снять галочки, вернуть обратно ссылку на проект. Я попросту откатываю изменения файла **EasyEPlanner.csproj** в **Git** репозитории проекта и все.

Следующий этап - это подписать надстройку. Так как мы собирали надстройку в конфигурации **ReleaseSigned**, то идем в папку **bin/ReleaseSigned**, где должна лежать подписанная надстройка. Если это финальная версия надстройки, которая должна быть передана пользователям, не забудьте обновить измененные файлы **Lua**, и другие, если они есть. Если Вы добавили новые файлы, проверьте, что они были скопированы в папку сборки, а затем руками их перенесите туда, где лежит надстройка для пользователей т.к нет механизма развертывания.

И так, надстройка подписана нами, но не подписана **EPLAN**. Нужно подписать её, отправив на сервер подписи. Логин и пароль возьмите у Вашего руководителя. Адрес сервера - https://service.eplan.de/exchange.

После входа в систему, можно посмотреть уже загруженные и подписанные надстройки (*прошлые версии, которые мы делали*).

<p align="center"><img src="images/sign-add-in-first-step.png" /></p>
<p align="center">Рисунок - Интерфейс сервера подписей</p>

**MyDownloads** - то, где мы сейчас находимся. Скачать надстройку можно, нажав кнопку слева от красного крестика (__красный крестик - удаление__). Периодически старые надстройки нужно удалять т.к они занимают место (*у нас они есть в SVN подписанные*).

Для загрузки надстройки на подпись, нажимаем слева пункт меню "**Upload one file**", появится новое окно.

<p align="center"><img src="images/sign-add-in-second-step.png" /></p>
<p align="center">Рисунок - Загрузка надстройки на подпись</p>

Выбираем файл, предварительно загрузив его в **.zip** архив, и нажимаем кнопку **Upload**. После загрузки сервер покажет нам, что он загрузил, жмем **OK** и переходим обратно в **MyDownloads**. Появится новая строка с нашей подписанной надстройкой. Качаем её, распаковываем, переносим в каталог для пользователей и проверяем.

Дополнительно, в архиве с надстройкой появится файл логов, по которому можно заранее узнать, подписалась надстройка успешно или нет.

### 3.4 Как отлаживать надстройку ###

**Внимание**: если вы добавляете новые **Lua** файлы, или файлы, которые должны быть в каталоге с надстройкой для пользователя, не забывайте их копировать вручную в этот каталог из каталога сборки т.к. у нас нет автоматических механизмов развертывания.

**Пример**: добавили файл в папку **Lua**, и используете его в надстройке. Проверьте, чтобы стояло в настройках "*Копировать новые версии файла*" и не забудьте скопировать эту версию из папки **ReleaseSigned** (*можно и из Debug, если версии файлов одинаковые, это не принципиально*) в то же место, только в папке с надстройкой для пользователей. Не стоит копировать библиотеки, которые находятся в глобальном кэше сборок **GAC** т.к система их подхватит автоматически.

## Вопросы пользователей, частые изменения в проекте ##

Здесь описаны наиболее частые вопросы пользователей, а также то, какие файлы в проекте чаще всего меняются, или что надо учесть, когда их меняешь. Все написано сугубо по памяти и не может быть использовано как абсолютная правда.